<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë§ˆí”¼ì•„ ê²Œì„ (Mafia Online)</title>
    <!-- Favicon: ê²€ ëª¨ì–‘ (ğŸ—¡ï¸) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ—¡ï¸</text></svg>">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Icons (Phosphor Icons) -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700;900&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        .animate-fade-in { animation: fadeIn 0.5s ease-in-out; }
        .animate-delayed-fade-in { animation: fadeIn 1s ease-in-out 0.5s forwards; opacity: 0; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- Special Nickname Effects --- */
        .rainbow-text {
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            background-size: 200% 100%;
            animation: rainbow-shift 4s linear infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            font-weight: 900; 
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }
        
        .ocean-blue-text {
            background: linear-gradient(90deg, #00C9FF, #92FE9D);
            background-size: 200% 100%;
            animation: rainbow-shift 5s linear infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            color: transparent;
            font-weight: 900;
            text-shadow: 0 0 5px rgba(0, 200, 255, 0.3);
        }

        /* Updated Shiny Border: Runs only 3 times then stops */
        .shiny-border {
            border: 2px solid #FFD700 !important;
            box-shadow: 0 0 5px #FFD700; 
            animation: pulse-gold 1.5s 3 ease-in-out forwards; /* 3íšŒ ë°˜ë³µ í›„ ì •ì§€ */
        }

        @keyframes rainbow-shift { to { background-position: -200% 0; } }
        @keyframes pulse-gold {
            0% { box-shadow: 0 0 5px #FFD700; }
            50% { box-shadow: 0 0 20px #FFD700, 0 0 10px white; }
            100% { box-shadow: 0 0 5px #FFD700; }
        }

        /* --- Night Atmosphere --- */
        .night-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 0;
            box-shadow: inset 0 0 150px rgba(0,0,0,0.9);
            animation: night-pulse 4s infinite ease-in-out;
        }
        @keyframes night-pulse {
            0% { background-color: rgba(0,0,0,0.1); box-shadow: inset 0 0 100px rgba(0,0,0,0.8); }
            50% { background-color: rgba(20,0,0,0.2); box-shadow: inset 0 0 200px rgba(50,0,0,0.8); } 
            100% { background-color: rgba(0,0,0,0.1); box-shadow: inset 0 0 100px rgba(0,0,0,0.8); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics.js";
        import { 
            getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { 
            getFirestore, collection, addDoc, doc, getDoc, getDocs, updateDoc, 
            onSnapshot, query, where, deleteDoc, serverTimestamp, setDoc, 
            arrayUnion, arrayRemove, runTransaction, increment
        } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCLZhWWBvaKTz45CW_s1iJnBPLTCwxRHCE",
            authDomain: "testy-c.firebaseapp.com",
            projectId: "testy-c",
            storageBucket: "testy-c.firebasestorage.app",
            messagingSenderId: "312428887371",
            appId: "1:312428887371:web:327ffb3ae148f871127cce",
            measurementId: "G-JJ9WM2ZJBN"
        };

        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const { useState, useEffect, useRef, useMemo } = React;

        const PROFANITY_LIST = ['ë°”ë³´', 'ë©ì²­ì´', 'ì‹œë°œ', 'ì”¨ë°œ', 'ê°œìƒˆë¼', 'ë³‘ì‹ ', 'ëŠê¸ˆë§ˆ', 'ì• ë¯¸', 'ì• ë¹„', 'ì§€ë„', 'ë‹¥ì³'];
        const ROLES = { CITIZEN: 'ì‹œë¯¼', MAFIA: 'ë§ˆí”¼ì•„', POLICE: 'ê²½ì°°', DOCTOR: 'ì˜ì‚¬' };
        const PHASES = {
            WAITING: 'waiting',
            ROLE_REVEAL: 'role_reveal', 
            NIGHT_INTRO: 'night_intro', 
            NIGHT_MAFIA: 'night_mafia',   
            NIGHT_POLICE: 'night_police', 
            NIGHT_DOCTOR: 'night_doctor', 
            DAY_INTRO: 'day_intro',     
            DAY_VOTE: 'day_vote',       
            DAY_VOTE_TALLY: 'day_vote_tally',
            DAY_RESULT: 'day_result',   
            GAME_OVER: 'game_over'
        };

        const checkProfanity = (text) => PROFANITY_LIST.some(word => text.includes(word));

        // --- Components ---
        function App() {
            const [user, setUser] = useState(null);
            const [nickname, setNickname] = useState(null);
            const [currentRoomId, setCurrentRoomId] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
                    if (firebaseUser) {
                        const userRef = doc(db, 'users', firebaseUser.uid);
                        const userSnap = await getDoc(userRef);
                        if (userSnap.exists()) setNickname(userSnap.data().nickname);
                        setUser(firebaseUser);
                    } else {
                        setUser(null); setNickname(null); setCurrentRoomId(null);
                    }
                    setLoading(false);
                });
                return () => unsubscribe();
            }, []);

            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (currentRoomId) { e.preventDefault(); e.returnValue = ''; }
                };
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [currentRoomId]);

            if (loading) return <div className="flex h-screen items-center justify-center text-2xl">Loading...</div>;
            if (!user) return <LoginScreen />;
            if (!nickname) return <NicknameSetup user={user} setNickname={setNickname} />;
            if (currentRoomId) return <GameRoom roomId={currentRoomId} user={user} nickname={nickname} onLeave={() => setCurrentRoomId(null)} />;
            return <Lobby user={user} nickname={nickname} setNickname={setNickname} onJoinRoom={setCurrentRoomId} />;
        }

        function LoginScreen() {
            const handleLogin = async () => {
                const provider = new GoogleAuthProvider();
                try { await signInWithPopup(auth, provider); } 
                catch (e) { alert("ë¡œê·¸ì¸ ì‹¤íŒ¨: " + e.message); }
            };
            return (
                <div className="flex h-screen flex-col items-center justify-center bg-gray-900 text-white p-4">
                    <div className="text-center space-y-6 animate-fade-in">
                        <h1 className="text-6xl font-black text-red-600 tracking-tighter drop-shadow-lg mb-8">MAFIA</h1>
                        <button onClick={handleLogin} className="bg-white text-gray-900 font-bold py-3 px-8 rounded-full hover:bg-gray-200 transition flex items-center gap-2 mx-auto">
                            <img src="https://www.svgrepo.com/show/475656/google-color.svg" className="w-6 h-6" />
                            Google ê³„ì •ìœ¼ë¡œ ì‹œì‘
                        </button>
                    </div>
                </div>
            );
        }

        function NicknameSetup({ user, setNickname }) {
            const [input, setInput] = useState('');
            const [error, setError] = useState('');
            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!input.trim()) return;
                if (checkProfanity(input)) { setError("ë¶€ì ì ˆí•œ ë‹¨ì–´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."); return; }
                const q = query(collection(db, 'users'), where('nickname', '==', input));
                const snapshot = await getDocs(q);
                if (!snapshot.empty) { setError("ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤."); return; }
                
                await setDoc(doc(db, 'users', user.uid), { 
                    nickname: input, 
                    uid: user.uid, 
                    email: user.email,
                    lastNicknameChange: Date.now() 
                });
                setNickname(input);
            };
            return (
                <div className="flex h-screen items-center justify-center bg-gray-800">
                    <form onSubmit={handleSubmit} className="bg-gray-900 p-8 rounded-xl border border-gray-700 w-96">
                        <h2 className="text-2xl font-bold mb-4">ë‹‰ë„¤ì„ ì„¤ì •</h2>
                        <input value={input} onChange={e=>setInput(e.target.value)} className="w-full bg-gray-800 border border-gray-600 rounded p-2 mb-2 focus:border-red-500 outline-none" placeholder="ì‚¬ìš©í•  ë‹‰ë„¤ì„ ì…ë ¥" />
                        {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
                        <button type="submit" className="w-full bg-red-600 hover:bg-red-700 py-2 rounded font-bold">í™•ì¸</button>
                    </form>
                </div>
            );
        }

        function NicknameChangeModal({ user, onClose, onUpdateNickname }) {
            const [input, setInput] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(true);
            const [canChange, setCanChange] = useState(false);
            const [timeLeftMsg, setTimeLeftMsg] = useState('');

            useEffect(() => {
                const checkCooldown = async () => {
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    if (userDoc.exists()) {
                        const data = userDoc.data();
                        const lastChange = data.lastNicknameChange || 0;
                        const now = Date.now();
                        const diff = now - lastChange;
                        const cooldown = 30 * 24 * 60 * 60 * 1000; 

                        if (diff < cooldown) {
                            const remaining = cooldown - diff;
                            const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
                            const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                            setCanChange(false);
                            setTimeLeftMsg(`${days}ì¼ ${hours}ì‹œê°„ í›„ì— ë³€ê²½ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
                        } else {
                            setCanChange(true);
                        }
                    } else {
                        setCanChange(true);
                    }
                    setLoading(false);
                };
                checkCooldown();
            }, [user.uid]);

            const handleSubmit = async () => {
                if (!canChange) return;
                if (!input.trim()) { setError("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."); return; }
                if (checkProfanity(input)) { setError("ë¶€ì ì ˆí•œ ë‹¨ì–´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤."); return; }
                
                const q = query(collection(db, 'users'), where('nickname', '==', input));
                const snapshot = await getDocs(q);
                if (!snapshot.empty) { setError("ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤."); return; }

                await updateDoc(doc(db, 'users', user.uid), {
                    nickname: input,
                    lastNicknameChange: Date.now()
                });
                onUpdateNickname(input);
                onClose();
            };

            return (
                <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                    <div className="bg-gray-800 p-6 rounded-lg w-96 border border-gray-600">
                        <h3 className="text-xl font-bold mb-4">ë‹‰ë„¤ì„ ë³€ê²½</h3>
                        {loading ? <p>ì •ë³´ í™•ì¸ ì¤‘...</p> : (
                            <>
                                {!canChange ? (
                                    <div className="text-center space-y-4">
                                        <p className="text-red-400 font-bold">ë³€ê²½ ë¶ˆê°€</p>
                                        <p className="text-gray-400 text-sm">{timeLeftMsg}</p>
                                        <button onClick={onClose} className="w-full py-2 bg-gray-600 rounded hover:bg-gray-500">ë‹«ê¸°</button>
                                    </div>
                                ) : (
                                    <div className="space-y-4">
                                        <p className="text-xs text-gray-400">30ì¼ì— í•œ ë²ˆë§Œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                                        <input value={input} onChange={e => setInput(e.target.value)} className="w-full bg-gray-700 p-2 rounded text-white border border-gray-600 focus:border-blue-500 outline-none" placeholder="ìƒˆ ë‹‰ë„¤ì„"/>
                                        {error && <p className="text-red-500 text-xs">{error}</p>}
                                        <div className="flex gap-2 justify-end">
                                            <button onClick={onClose} className="px-4 py-2 text-gray-400 hover:text-white">ì·¨ì†Œ</button>
                                            <button onClick={handleSubmit} className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded font-bold">ë³€ê²½í•˜ê¸°</button>
                                        </div>
                                    </div>
                                )}
                            </>
                        )}
                    </div>
                </div>
            );
        }

        function Lobby({ user, nickname, setNickname, onJoinRoom }) {
            const [rooms, setRooms] = useState([]);
            const [showCreate, setShowCreate] = useState(false);
            const [showProfile, setShowProfile] = useState(false);
            const [showNickChange, setShowNickChange] = useState(false);

            useEffect(() => {
                const q = query(collection(db, 'rooms')); 
                const unsub = onSnapshot(q, (snap) => setRooms(snap.docs.map(d => ({id: d.id, ...d.data()}))));
                return () => unsub();
            }, []);
            const handleJoin = async (room) => {
                // ì¤‘ë„ ì…ì¥ ì°¨ë‹¨
                if (room.status === 'playing') { alert("ì´ë¯¸ ê²Œì„ì´ ì§„í–‰ ì¤‘ì¸ ë°©ì…ë‹ˆë‹¤."); return; }
                
                if (room.password) {
                    const pw = prompt("ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
                    if (pw !== room.password) { alert("ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤."); return; }
                }
                if (room.players.length >= room.settings.maxPlayers) { alert("ë°©ì´ ê½‰ ì°¼ìŠµë‹ˆë‹¤."); return; }
                onJoinRoom(room.id);
            };
            return (
                <div className="min-h-screen bg-gray-900 flex flex-col">
                    <header className="bg-gray-800 p-4 flex justify-between items-center border-b border-gray-700">
                        <div className="font-black text-2xl text-red-600 tracking-widest">MAFIA GAME</div>
                        <div className="relative">
                            <button onClick={() => setShowProfile(!showProfile)} className="font-bold hover:text-red-400 transition flex items-center gap-2">
                                {nickname} ë‹˜ <i className="ph ph-caret-down"></i>
                            </button>
                            {showProfile && (
                                <div className="absolute right-0 mt-2 w-40 bg-gray-700 rounded shadow-xl overflow-hidden z-50 border border-gray-600">
                                    <button onClick={() => { setShowNickChange(true); setShowProfile(false); }} className="w-full text-left p-3 hover:bg-gray-600 text-white border-b border-gray-600 flex items-center gap-2"><i className="ph ph-pencil-simple"></i> ë‹‰ë„¤ì„ ë³€ê²½</button>
                                    <button onClick={() => signOut(auth)} className="w-full text-left p-3 hover:bg-gray-600 text-red-300 flex items-center gap-2"><i className="ph ph-sign-out"></i> ë¡œê·¸ì•„ì›ƒ</button>
                                </div>
                            )}
                        </div>
                    </header>
                    <main className="flex-1 p-6 max-w-6xl mx-auto w-full">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-bold flex items-center gap-2"><i className="ph ph-list-dashes"></i> ë°© ë¦¬ìŠ¤íŠ¸</h2>
                            <button onClick={() => setShowCreate(true)} className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded font-bold flex items-center gap-2"><i className="ph ph-plus-circle text-xl"></i> ë°© ë§Œë“¤ê¸°</button>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            {rooms.map(room => (
                                <div key={room.id} onClick={() => handleJoin(room)} className={`bg-gray-800 border ${room.password ? 'border-yellow-700' : 'border-gray-700'} hover:border-red-500 p-4 rounded-lg cursor-pointer transition relative overflow-hidden group ${room.status === 'playing' ? 'opacity-50 grayscale' : ''}`}>
                                    <div className="flex justify-between items-start mb-2">
                                        <h3 className="font-bold text-lg truncate w-4/5">{room.title}</h3>
                                        {room.password ? <i className="ph ph-lock-key text-yellow-500 text-xl"></i> : <i className="ph ph-lock-key-open text-green-500 text-xl"></i>}
                                    </div>
                                    <div className="flex justify-between items-end mt-4">
                                        <div className="text-xs text-gray-400 space-y-1">
                                            <p>ë§ˆí”¼ì•„:{room.settings.mafia} ì˜ì‚¬:{room.settings.doctor} ê²½ì°°:{room.settings.police}</p>
                                            <p className={room.status === 'playing' ? 'text-red-500 font-bold' : 'text-green-500'}>{room.status === 'playing' ? 'ê²Œì„ ì¤‘' : 'ëŒ€ê¸° ì¤‘'}</p>
                                        </div>
                                        <span className="text-2xl font-black text-gray-500 group-hover:text-white transition">{room.players.length}<span className="text-sm text-gray-600">/{room.settings.maxPlayers}</span></span>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </main>
                    {showCreate && <CreateRoomModal user={user} nickname={nickname} onClose={() => setShowCreate(false)} onJoin={onJoinRoom} />}
                    {showNickChange && <NicknameChangeModal user={user} onClose={() => setShowNickChange(false)} onUpdateNickname={setNickname} />}
                </div>
            );
        }

        function CreateRoomModal({ user, nickname, onClose, onJoin }) {
            const [title, setTitle] = useState('');
            const [password, setPassword] = useState('');
            const [maxPlayers, setMaxPlayers] = useState(6);
            const [roles, setRoles] = useState({ mafia: 1, doctor: 1, police: 1 });
            const handleCreate = async () => {
                if (!title.trim()) return;
                const needed = roles.mafia + roles.doctor + roles.police + 1;
                if (maxPlayers < needed) { alert(`ìµœì†Œ ${needed}ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤.`); return; }
                const roomRef = await addDoc(collection(db, 'rooms'), {
                    title, password, hostId: user.uid, status: 'waiting',
                    settings: { maxPlayers: parseInt(maxPlayers), ...roles },
                    players: [{ uid: user.uid, nickname, role: null, isAlive: true, isReady: false, isHost: true }],
                    createdAt: serverTimestamp(),
                    gameState: { phase: 'waiting', dayCount: 0, timerEnd: null, nightResults: {}, voteList: {} },
                    lastHealedId: null
                });
                onJoin(roomRef.id); onClose();
            };
            return (
                <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                    <div className="bg-gray-800 p-6 rounded-lg w-96 border border-gray-600">
                        <h3 className="text-xl font-bold mb-4">ë°© ë§Œë“¤ê¸°</h3>
                        <input className="w-full bg-gray-700 p-2 rounded mb-2 text-white" placeholder="ë°© ì œëª©" value={title} onChange={e=>setTitle(e.target.value)} />
                        <input className="w-full bg-gray-700 p-2 rounded mb-4 text-white" placeholder="ë¹„ë°€ë²ˆí˜¸ (ì„ íƒ)" type="password" value={password} onChange={e=>setPassword(e.target.value)} />
                        <div className="mb-4"><label className="block text-sm text-gray-400 mb-1">ì´ ì¸ì›: {maxPlayers}ëª…</label><input type="range" min="4" max="10" value={maxPlayers} onChange={e=>setMaxPlayers(e.target.value)} className="w-full accent-red-600" /></div>
                        <div className="grid grid-cols-3 gap-2 mb-6">
                            <div className="text-center"><span className="text-xs text-red-400 block">ë§ˆí”¼ì•„</span><input type="number" min="1" max="3" className="w-full bg-gray-700 text-center rounded" value={roles.mafia} onChange={e=>setRoles({...roles, mafia:parseInt(e.target.value)})} /></div>
                            <div className="text-center"><span className="text-xs text-green-400 block">ì˜ì‚¬</span><input type="number" min="1" max="2" className="w-full bg-gray-700 text-center rounded" value={roles.doctor} onChange={e=>setRoles({...roles, doctor:parseInt(e.target.value)})} /></div>
                            <div className="text-center"><span className="text-xs text-blue-400 block">ê²½ì°°</span><input type="number" min="1" max="2" className="w-full bg-gray-700 text-center rounded" value={roles.police} onChange={e=>setRoles({...roles, police:parseInt(e.target.value)})} /></div>
                        </div>
                        <div className="flex justify-end gap-2"><button onClick={onClose} className="px-4 py-2 text-gray-400">ì·¨ì†Œ</button><button onClick={handleCreate} className="px-4 py-2 bg-red-600 rounded font-bold">ìƒì„±</button></div>
                    </div>
                </div>
            );
        }

        function GameRoom({ roomId, user, nickname, onLeave }) {
            const [room, setRoom] = useState(null);
            const [chatMsg, setChatMsg] = useState('');
            const [chatLogs, setChatLogs] = useState([]);
            const chatEndRef = useRef(null);
            const hasJoinedRef = useRef(false);
            const [timeLeft, setTimeLeft] = useState(0);

            useEffect(() => {
                if(!room?.gameState?.phaseEndTime) return;
                const interval = setInterval(() => {
                    const diff = Math.max(0, Math.ceil((room.gameState.phaseEndTime - Date.now()) / 1000));
                    setTimeLeft(diff);
                }, 1000);
                return () => clearInterval(interval);
            }, [room?.gameState?.phaseEndTime]);

            useEffect(() => {
                const unsub = onSnapshot(doc(db, 'rooms', roomId), (docSnap) => {
                    if (!docSnap.exists()) { alert("ë°©ì´ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤."); onLeave(); return; }
                    const data = docSnap.data();
                    const me = data.players.find(p => p.uid === user.uid);
                    if (me) hasJoinedRef.current = true;
                    if (hasJoinedRef.current && !me && data.status === 'waiting') { alert("ê°•í‡´ë‹¹í–ˆìŠµë‹ˆë‹¤."); onLeave(); return; }
                    setRoom(data);
                });
                return () => unsub();
            }, [roomId]);

            useEffect(() => {
                const q = query(collection(db, 'rooms', roomId, 'messages'), where('timestamp', '!=', null)); 
                const unsub = onSnapshot(collection(db, 'rooms', roomId, 'messages'), (snap) => {
                    const msgs = snap.docs.map(d => d.data()).sort((a,b) => a.timestamp - b.timestamp);
                    setChatLogs(msgs);
                    setTimeout(() => chatEndRef.current?.scrollIntoView({behavior: "smooth"}), 100);
                });
                return () => unsub();
            }, [roomId]);

            useEffect(() => {
                const join = async () => {
                    const roomRef = doc(db, 'rooms', roomId);
                    await runTransaction(db, async (transaction) => {
                        const sfDoc = await transaction.get(roomRef);
                        if (!sfDoc.exists()) return;
                        const data = sfDoc.data();
                        const existingPlayer = data.players.find(p => p.uid === user.uid);
                        if (!existingPlayer) {
                            const newPlayers = [...data.players, { uid: user.uid, nickname, role: null, isAlive: true, isReady: false, isHost: false }];
                            transaction.update(roomRef, { players: newPlayers });
                        }
                    });
                };
                join();
                return () => leaveRoom();
            }, []);

            const leaveRoom = async () => {
                const roomRef = doc(db, 'rooms', roomId);
                const snap = await getDoc(roomRef);
                if (!snap.exists()) return;
                const data = snap.data();
                let newPlayers = data.players.filter(p => p.uid !== user.uid);
                let updates = { players: newPlayers };
                if (newPlayers.length === 0) { await deleteDoc(roomRef); } 
                else {
                    if (data.hostId === user.uid) { updates.hostId = newPlayers[0].uid; newPlayers[0].isHost = true; }
                    await updateDoc(roomRef, updates);
                }
            };

            const sendChat = async (e) => {
                e.preventDefault();
                if (!chatMsg.trim()) return;
                const me = room.players.find(p => p.uid === user.uid);
                if (!me.isAlive) { alert("ì£½ì€ ìëŠ” ë§ì´ ì—†ìŠµë‹ˆë‹¤."); setChatMsg(''); return; }
                if (room.gameState.phase.startsWith('night_') || room.gameState.phase === PHASES.NIGHT_INTRO) { alert("ë°¤ì—ëŠ” ì±„íŒ…ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); setChatMsg(''); return; }
                await addDoc(collection(db, 'rooms', roomId, 'messages'), { sender: nickname, text: chatMsg, timestamp: serverTimestamp() });
                setChatMsg('');
            };

            const handleSkipVote = async () => {
                const me = room.players.find(p => p.uid === user.uid);
                if(!me.isAlive) return;
                if (room.gameState.voteList?.day?.[me.uid]) { alert("ì´ë¯¸ íˆ¬í‘œí–ˆìŠµë‹ˆë‹¤."); return; }
                if(!confirm("íˆ¬í‘œë¥¼ ê±´ë„ˆë›°ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
                
                // Use 'SKIP' as the target ID for skipping
                await updateDoc(doc(db, 'rooms', roomId), { [`gameState.voteList.day.${me.uid}`]: 'SKIP' });
            };

            if (!room) return <div>Loading room...</div>;
            const me = room.players.find(p => p.uid === user.uid) || {};
            const isNight = room.gameState.phase.startsWith('night_') || room.gameState.phase === PHASES.NIGHT_INTRO;
            
            return (
                <div className={`flex flex-col h-screen ${isNight ? 'bg-black text-gray-300' : 'bg-gray-900 text-white'} transition-colors duration-1000 relative`}>
                    {/* Night Atmosphere Effect */}
                    {isNight && <div className="night-overlay"></div>}
                    
                    <div className="p-3 border-b border-gray-700 flex justify-between items-center bg-opacity-50 bg-gray-800 z-10">
                        <div className="flex items-center gap-4">
                            <button onClick={() => { if(confirm("ì •ë§ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?")) onLeave(); }} className="text-gray-400 hover:text-white"><i className="ph ph-sign-out text-2xl"></i></button>
                            <h2 className="font-bold text-lg">{room.title} <span className="text-sm font-normal ml-2 text-gray-400">({room.players.length}/{room.settings.maxPlayers})</span></h2>
                        </div>
                        <div className="flex flex-col items-center">
                             {room.gameState.phase === PHASES.WAITING ? <span className="text-green-400">ëŒ€ê¸° ì¤‘</span> : 
                              <div className="text-center">
                                  <span className="font-mono text-xl text-yellow-400">{room.gameState.dayCount}ì¼ì°¨ {isNight ? 'ğŸŒ™ ë°¤' : 'â˜€ï¸ ë‚®'}</span>
                                  {(room.gameState.phase.startsWith('night_') || room.gameState.phase === PHASES.DAY_VOTE) && <div className="text-red-500 font-bold text-2xl animate-pulse">{Math.floor(timeLeft / 60)}:{(timeLeft % 60).toString().padStart(2, '0')}</div>}
                                  {room.gameState.phase === PHASES.NIGHT_MAFIA && <span className="block text-sm text-red-500">ë§ˆí”¼ì•„ í„´</span>}
                                  {room.gameState.phase === PHASES.NIGHT_POLICE && <span className="block text-sm text-blue-500">ê²½ì°° í„´</span>}
                                  {room.gameState.phase === PHASES.NIGHT_DOCTOR && <span className="block text-sm text-green-500">ì˜ì‚¬ í„´</span>}
                                  {room.gameState.phase === PHASES.DAY_VOTE_TALLY && <span className="block text-sm text-yellow-500 font-bold">íˆ¬í‘œ ì§‘ê³„ ì¤‘...</span>}
                              </div>
                             }
                        </div>
                        <div><span className={`font-bold px-2 py-1 rounded ${me.role === ROLES.MAFIA ? 'bg-red-900 text-red-200' : 'bg-gray-700'}`}>ë‚´ ì—­í• : {me.role || '?'}</span></div>
                    </div>
                    <div className="flex-1 flex overflow-hidden z-10">
                        <div className="flex-1 p-4 overflow-y-auto relative">
                            <GameNotification phase={room.gameState.phase} logs={room.gameState.logs} lastExecuted={room.gameState.lastExecuted} isHost={me.isHost} room={room} roomId={roomId} voteList={room.gameState.voteList} players={room.players} />
                            <div className="grid grid-cols-2 md:grid-cols-3 gap-4 max-w-4xl mx-auto mt-8">
                                {room.players.map(player => <PlayerCard key={player.uid} player={player} me={me} room={room} roomId={roomId} />)}
                            </div>
                            
                            {/* Skip Vote Button */}
                            {room.gameState.phase === PHASES.DAY_VOTE && me.isAlive && !room.gameState.voteList?.day?.[me.uid] && (
                                <div className="absolute bottom-4 right-4 animate-fade-in">
                                    <button onClick={handleSkipVote} className="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-full shadow-lg flex items-center gap-2">
                                        <i className="ph ph-fast-forward"></i> íˆ¬í‘œ ê±´ë„ˆë›°ê¸°
                                    </button>
                                </div>
                            )}

                            {room.status === 'waiting' && <WaitingRoomControls room={room} me={me} roomId={roomId} />}
                            {me.isHost && <HostLogic room={room} roomId={roomId} />}
                        </div>
                    </div>
                    <div className="h-1/3 bg-gray-800 border-t border-gray-700 flex flex-col z-10">
                        <div className="flex-1 overflow-y-auto p-4 space-y-2">
                            {chatLogs.map((msg, i) => <div key={i} className="text-sm"><span className="font-bold text-gray-400">{msg.sender}:</span> <span className="text-gray-200">{msg.text}</span></div>)}
                            <div ref={chatEndRef}></div>
                        </div>
                        {me.isAlive && !isNight && <form onSubmit={sendChat} className="p-2 bg-gray-900 flex gap-2"><input className="flex-1 bg-gray-800 text-white p-2 rounded outline-none focus:ring-1 focus:ring-red-500" value={chatMsg} onChange={e => setChatMsg(e.target.value)} placeholder="ì±„íŒ… ì…ë ¥..." /><button type="submit" className="bg-gray-700 px-4 py-2 rounded hover:bg-gray-600"><i className="ph ph-paper-plane-right"></i></button></form>}
                        {isNight && <div className="p-3 text-center text-gray-600">ë°¤ì—ëŠ” ì±„íŒ…ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</div>}
                    </div>
                </div>
            );
        }

        function PlayerCard({ player, me, room, roomId }) {
            const isDead = !player.isAlive;
            const isMe = player.uid === me.uid;
            const [showVoteBtn, setShowVoteBtn] = useState(false);
            const [showKickBtn, setShowKickBtn] = useState(false);
            const hasVoted = room.gameState.voteList?.day?.[me.uid];
            
            // Special Nicknames Logic
            const isRainbow = ['Admin', 'ì°¸ì¹˜ë®ë°¥', 'ë·'].includes(player.nickname);
            const isOcean = player.nickname === 'ì§€ì¹´ í‚¬ëŸ¬';
            const isShiny = ['Admin', 'ì°¸ì¹˜ë®ë°¥', 'ë·'].includes(player.nickname);
            
            const isTeammate = me.role === player.role && !isMe && me.role !== ROLES.CITIZEN && me.role;

            const handleClick = () => {
                if (room.status === 'waiting' && me.isHost && !player.isHost && !isMe) {
                     setShowKickBtn(!showKickBtn);
                     return;
                }
                if(isDead || !me.isAlive) return;
                if (isMe && !(me.role === ROLES.DOCTOR && room.gameState.phase === PHASES.NIGHT_DOCTOR)) return;

                const phase = room.gameState.phase;
                if(phase === PHASES.DAY_VOTE) {
                    if(isMe) return; 
                    if(hasVoted) { alert("ì´ë¯¸ íˆ¬í‘œí•˜ì…¨ìŠµë‹ˆë‹¤."); return; }
                    setShowVoteBtn(!showVoteBtn);
                } 
                else if (phase === PHASES.NIGHT_MAFIA && me.role === ROLES.MAFIA && !isMe) handleNightAction('mafia');
                else if (phase === PHASES.NIGHT_POLICE && me.role === ROLES.POLICE && !isMe) handleNightAction('police');
                else if (phase === PHASES.NIGHT_DOCTOR && me.role === ROLES.DOCTOR) handleNightAction('doctor');
            };

            const handleVote = async (e) => {
                e.stopPropagation();
                if(!confirm(`${player.nickname}ë‹˜ì—ê²Œ íˆ¬í‘œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
                await updateDoc(doc(db, 'rooms', roomId), { [`gameState.voteList.day.${me.uid}`]: player.uid });
                setShowVoteBtn(false);
            };

            const handleKick = async (e) => {
                e.stopPropagation();
                if (!confirm(`${player.nickname}ë‹˜ì„ ê°•í‡´í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
                const newPlayers = room.players.filter(p => p.uid !== player.uid);
                await updateDoc(doc(db, 'rooms', roomId), { players: newPlayers });
            };

            const handleNightAction = async (type) => {
                 const hasActed = Object.keys(room.gameState.voteList[type] || {}).includes(me.uid);
                 if (hasActed) { alert("ì´ë²ˆ ë°¤ì—ëŠ” ì´ë¯¸ ëŠ¥ë ¥ì„ ì‚¬ìš©í•˜ì…¨ìŠµë‹ˆë‹¤."); return; }
                 if(!confirm(`${player.nickname}ë‹˜ì„ ì„ íƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
                 
                 const actionKey = `gameState.voteList.${type}.${me.uid}`;
                 if (type === 'mafia') {
                    await updateDoc(doc(db, 'rooms', roomId), { [actionKey]: player.uid });
                    alert(`${player.nickname}ë‹˜ì„ ì²˜í˜• ëŒ€ìƒìœ¼ë¡œ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`);
                } else if (type === 'police') {
                    await updateDoc(doc(db, 'rooms', roomId), { [actionKey]: player.uid });
                    alert(`${player.nickname}ë‹˜ì„ ì¡°ì‚¬í•©ë‹ˆë‹¤.`);
                } else if (type === 'doctor') {
                    await updateDoc(doc(db, 'rooms', roomId), { [actionKey]: player.uid });
                    alert(`${player.nickname}ë‹˜ì„ ì¹˜ë£Œí•©ë‹ˆë‹¤.`);
                }
            };

            let canAct = false;
            const hasActed = room.gameState.voteList?.[me.role?.toLowerCase()]?.[me.uid];
            if (me.isAlive && !isDead && !hasActed) {
                if (room.gameState.phase === PHASES.NIGHT_MAFIA && me.role === ROLES.MAFIA && !isMe) canAct = true;
                if (room.gameState.phase === PHASES.NIGHT_POLICE && me.role === ROLES.POLICE && !isMe) canAct = true;
                if (room.gameState.phase === PHASES.NIGHT_DOCTOR && me.role === ROLES.DOCTOR) canAct = true; 
            }

            // Nickname Class Logic
            let nickClass = "font-bold";
            if (isRainbow) nickClass = "rainbow-text text-xl";
            else if (isOcean) nickClass = "ocean-blue-text text-xl";

            return (
                <div onClick={handleClick} className={`
                    relative p-4 rounded-lg border-2 flex flex-col items-center gap-2 cursor-pointer transition transform hover:scale-105
                    ${isDead ? 'border-gray-800 opacity-50 grayscale' : 'border-gray-600 bg-gray-800'}
                    ${canAct ? 'border-red-500 ring-2 ring-red-500 animate-pulse' : ''}
                    ${isMe ? 'ring-2 ring-blue-500 border-blue-500' : ''}
                    ${isShiny ? 'shiny-border' : ''}
                `}>
                    {isDead && <i className="ph ph-skull text-4xl text-gray-500 absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10"></i>}
                    <div className="w-12 h-12 rounded-full bg-gray-700 flex items-center justify-center text-xl font-bold">{player.nickname[0]}</div>
                    <span className={`truncate w-full text-center ${nickClass}`}>{player.nickname}</span>
                    {player.isHost && <span className="text-xs bg-yellow-600 px-2 py-0.5 rounded">ë°©ì¥</span>}
                    {(isMe || room.gameState.phase === PHASES.GAME_OVER) && <span className="text-xs text-gray-400">{player.role}</span>}
                    
                    {isTeammate && <span className="text-xs bg-indigo-600 text-white px-2 py-0.5 rounded animate-pulse">ë™ë£Œ</span>}
                    {room.status === 'waiting' && player.isReady && <span className="absolute -top-3 px-3 py-1 text-xs font-bold bg-green-600 text-white rounded-full shadow-lg border border-green-400 animate-fade-in">ì¤€ë¹„ ì™„ë£Œ!</span>}
                    
                    {showKickBtn && room.status === 'waiting' && (
                        <div className="absolute inset-0 bg-black/80 flex items-center justify-center rounded-lg z-20 animate-fade-in">
                            <button onClick={handleKick} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full shadow-lg">ê°•í‡´í•˜ê¸°</button>
                        </div>
                    )}

                    {showVoteBtn && !hasVoted && <div className="absolute inset-0 bg-black/80 flex items-center justify-center rounded-lg z-20 animate-fade-in"><button onClick={handleVote} className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full shadow-lg transform hover:scale-110 transition">íˆ¬í‘œí•˜ê¸°</button></div>}
                    {room.gameState.phase === PHASES.DAY_VOTE && room.gameState.voteList?.day?.[player.uid] && <div className="absolute top-2 right-2 w-3 h-3 bg-green-500 rounded-full" title="íˆ¬í‘œ ì™„ë£Œ"></div>}
                    {canAct && hasActed && <div className="absolute top-2 right-2 px-2 py-0.5 text-xs font-bold bg-green-500 text-white rounded-full">ì™„ë£Œ</div>}
                    {room.gameState.phase === PHASES.NIGHT_POLICE && me.role === ROLES.POLICE && room.gameState.voteList.police?.[me.uid] === player.uid && <div className="absolute bottom-2 text-xs font-bold text-blue-300">{player.role}</div>}
                </div>
            );
        }

        function WaitingRoomControls({ room, me, roomId }) {
            const toggleReady = async () => {
                const newPlayers = room.players.map(p => p.uid === me.uid ? { ...p, isReady: !p.isReady } : p);
                await updateDoc(doc(db, 'rooms', roomId), { players: newPlayers });
            };
            const startGame = async () => {
                if (room.players.length < 4) { alert("ìµœì†Œ 4ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }
                if (!room.players.every(p => p.isHost || p.isReady)) { alert("ë°©ì¥ì„ ì œì™¸í•œ ëª¨ë“  í”Œë ˆì´ì–´ê°€ ì¤€ë¹„í•´ì•¼ í•©ë‹ˆë‹¤."); return; }
                let availableRoles = [];
                for(let i=0; i<room.settings.mafia; i++) availableRoles.push(ROLES.MAFIA);
                for(let i=0; i<room.settings.police; i++) availableRoles.push(ROLES.POLICE);
                for(let i=0; i<room.settings.doctor; i++) availableRoles.push(ROLES.DOCTOR);
                while(availableRoles.length < room.players.length) availableRoles.push(ROLES.CITIZEN);
                availableRoles.sort(() => Math.random() - 0.5);
                const newPlayers = room.players.map((p, i) => ({ ...p, role: availableRoles[i], isAlive: true }));
                await updateDoc(doc(db, 'rooms', roomId), {
                    status: 'playing',
                    players: newPlayers,
                    gameState: { phase: PHASES.ROLE_REVEAL, dayCount: 1, phaseEndTime: Date.now() + 5000, logs: [], voteList: {}, nightResults: {} }
                });
            };
            return (
                <div className="absolute bottom-0 left-0 right-0 bg-gray-800 p-4 text-center border-t border-gray-700">
                    {me.isHost ? <button onClick={startGame} className="bg-red-600 hover:bg-red-700 text-white px-8 py-3 rounded-full font-bold text-xl shadow-lg animate-pulse">ê²Œì„ ì‹œì‘</button> : <button onClick={toggleReady} className={`px-8 py-3 rounded-full font-bold text-xl shadow-lg transition-colors duration-300 ${me.isReady ? 'bg-gray-600 hover:bg-gray-500 text-white' : 'bg-green-600 hover:bg-green-700 text-white'}`}>{me.isReady ? 'ì¤€ë¹„ ì·¨ì†Œ' : 'ì¤€ë¹„ ì™„ë£Œ'}</button>}
                </div>
            );
        }

        function GameNotification({ phase, logs, lastExecuted, isHost, room, roomId, voteList, players }) {
            const [showResult, setShowResult] = useState(false);
            
            useEffect(() => {
                if (phase === PHASES.DAY_RESULT) {
                    setShowResult(false);
                    const timer = setTimeout(() => setShowResult(true), 3000);
                    return () => clearTimeout(timer);
                } else {
                    setShowResult(false);
                }
            }, [phase]);

            const handleResetGame = async () => {
                if (!confirm("ëª¨ë“  í”Œë ˆì´ì–´ë¥¼ ëŒ€ê¸°ì‹¤ë¡œ ì´ë™ì‹œí‚¤ê² ìŠµë‹ˆê¹Œ?")) return;
                const newPlayers = room.players.map(p => ({ ...p, isAlive: true, role: null, isReady: false }));
                await updateDoc(doc(db, 'rooms', roomId), {
                    status: 'waiting',
                    players: newPlayers,
                    gameState: { phase: 'waiting', dayCount: 0, timerEnd: null, nightResults: {}, voteList: {} },
                    lastHealedId: null
                });
            };

            // Vote Tally Display
            if (phase === PHASES.DAY_VOTE_TALLY) {
                const votes = Object.values(voteList?.day || {});
                const voteCounts = votes.reduce((acc, uid) => { acc[uid] = (acc[uid] || 0) + 1; return acc; }, {});
                return (
                    <div className="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-8 text-center animate-fade-in">
                        <h2 className="text-4xl font-bold text-yellow-400 mb-6">íˆ¬í‘œ ì§‘ê³„ ì¤‘...</h2>
                        <div className="bg-gray-800 p-6 rounded-lg w-full max-w-md space-y-2">
                            {Object.entries(voteCounts).map(([uid, count]) => {
                                const targetName = uid === 'SKIP' ? "ê±´ë„ˆë›°ê¸°" : players.find(p => p.uid === uid)?.nickname || "ì•Œìˆ˜ì—†ìŒ";
                                return (
                                    <div key={uid} className="flex justify-between text-xl border-b border-gray-700 pb-2">
                                        <span>{targetName}</span>
                                        <span className="font-bold text-yellow-400">{count}í‘œ</span>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            }

            if (phase === PHASES.ROLE_REVEAL) return <OverlayMsg text="ì§ì—…ì´ ë°°ì •ë˜ì—ˆìŠµë‹ˆë‹¤." sub="ë‹¹ì‹ ì˜ ì—­í• ì„ í™•ì¸í•˜ì„¸ìš”." />;
            if (phase === PHASES.NIGHT_INTRO) return <OverlayMsg text="ë°¤ì´ ë˜ì—ˆìŠµë‹ˆë‹¤." sub="ê³§ ì§ì—… í™œë™ì´ ì‹œì‘ë©ë‹ˆë‹¤..." />;
            if (phase === PHASES.NIGHT_MAFIA || phase === PHASES.NIGHT_POLICE || phase === PHASES.NIGHT_DOCTOR) return null;

            if (phase === PHASES.DAY_INTRO) {
                const lastLog = logs[logs.length - 1] || {};
                return (
                    <div className="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-8 text-center animate-fade-in">
                        <h2 className="text-4xl font-bold text-yellow-400 mb-6">ì•„ì¹¨ì´ ë˜ì—ˆìŠµë‹ˆë‹¤</h2>
                        <div className="bg-gray-800 p-6 rounded-lg border border-gray-600 w-full max-w-lg text-left space-y-4">
                            <p>ğŸ”ª <span className="text-red-400">ë§ˆí”¼ì•„ ì²˜í˜•:</span> {lastLog.mafiaKill}</p>
                            <p>ğŸ’‰ <span className="text-green-400">ì˜ì‚¬ ì¹˜ë£Œ:</span> {lastLog.doctorSave}</p>
                            <p>ğŸ‘® <span className="text-blue-400">ê²½ì°° ì¡°ì‚¬:</span> {lastLog.policeInvest}</p>
                            <hr className="border-gray-600"/>
                            <p className="text-xl font-bold text-white">ğŸ’€ ì‚¬ë§ì: {lastLog.dead}</p>
                        </div>
                    </div>
                );
            }
            if (phase === PHASES.DAY_RESULT) {
                return (
                    <div className="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-8 text-center animate-fade-in">
                        <h2 className="text-4xl font-bold text-red-500 mb-4">íˆ¬í‘œ ê²°ê³¼</h2>
                        {lastExecuted ? (
                            <div className="space-y-8">
                                <p className="text-3xl text-white font-bold"><span className="text-yellow-400">{lastExecuted.nick}</span> ë‹˜ì€ ë§ˆí”¼ì•„ê°€...</p>
                                {showResult && (
                                    <p className="text-4xl animate-fade-in">
                                        <span className={lastExecuted.role === ROLES.MAFIA ? "text-green-500 font-black text-5xl" : "text-red-500 font-black text-5xl"}>
                                            {lastExecuted.role === ROLES.MAFIA ? "ë§ìŠµë‹ˆë‹¤!" : "ì•„ë‹™ë‹ˆë‹¤."}
                                        </span>
                                    </p>
                                )}
                            </div>
                        ) : (
                            <p className="text-2xl text-gray-400">íˆ¬í‘œ ê²°ê³¼, ì•„ë¬´ë„ ì²˜í˜•ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</p>
                        )}
                    </div>
                );
            }
            if (phase === PHASES.GAME_OVER) {
                const lastLog = logs[logs.length - 1] || {};
                // Wait 3 seconds before showing game over to allow result reading? No, logic handles transition.
                return (
                    <div className="absolute inset-0 bg-black/80 z-50 flex flex-col items-center justify-center animate-fade-in pointer-events-auto">
                        <h1 className="text-5xl font-black text-white mb-4 drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">
                            {lastLog.winner === 'mafia' ? "ë§ˆí”¼ì•„ ìŠ¹ë¦¬!" : "ì‹œë¯¼ ìŠ¹ë¦¬!"}
                        </h1>
                        <p className="text-2xl text-gray-400 mb-8">ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                        {isHost && (
                            <button onClick={handleResetGame} className="px-8 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full font-bold text-xl shadow-lg transition">
                                ëŒ€ê¸°ì‹¤ë¡œ ëŒì•„ê°€ê¸°
                            </button>
                        )}
                        {!isHost && <p className="text-gray-500">ë°©ì¥ì´ ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</p>}
                    </div>
                );
            }
            return null;
        }

        function OverlayMsg({ text, sub }) {
            return (
                <div className="absolute inset-0 bg-black/80 z-50 flex flex-col items-center justify-center animate-fade-in pointer-events-none">
                    <h1 className="text-5xl font-black text-white mb-4 drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">{text}</h1>
                    {sub && <p className="text-2xl text-gray-400">{sub}</p>}
                </div>
            );
        }

        function HostLogic({ room, roomId }) {
            useEffect(() => {
                const interval = setInterval(async () => {
                    if (!room || room.status !== 'playing') return;
                    const now = Date.now();
                    const gs = room.gameState;
                    let updates = {};
                    
                    if (gs.phase === PHASES.ROLE_REVEAL && now >= gs.phaseEndTime) {
                        updates = { 'gameState.phase': PHASES.NIGHT_INTRO, 'gameState.phaseEndTime': now + 3000 };
                    } 
                    else if (gs.phase === PHASES.NIGHT_INTRO && now >= gs.phaseEndTime) {
                        updates = { 'gameState.phase': PHASES.NIGHT_MAFIA, 'gameState.phaseEndTime': now + 10000, 'gameState.voteList': { mafia: {}, doctor: {}, police: {} } };
                    } 
                    else if (gs.phase === PHASES.NIGHT_MAFIA) {
                        const aliveCount = room.players.filter(p => p.isAlive && p.role === ROLES.MAFIA).length;
                        const voteCount = Object.keys(gs.voteList?.mafia || {}).length;
                        if (now >= gs.phaseEndTime || (aliveCount > 0 && voteCount >= aliveCount)) {
                            updates = { 'gameState.phase': PHASES.NIGHT_POLICE, 'gameState.phaseEndTime': now + 10000 };
                        }
                    }
                    else if (gs.phase === PHASES.NIGHT_POLICE) {
                        const aliveCount = room.players.filter(p => p.isAlive && p.role === ROLES.POLICE).length;
                        const voteCount = Object.keys(gs.voteList?.police || {}).length;
                        if (now >= gs.phaseEndTime || voteCount >= aliveCount) {
                            updates = { 'gameState.phase': PHASES.NIGHT_DOCTOR, 'gameState.phaseEndTime': now + 10000 };
                        }
                    }
                    else if (gs.phase === PHASES.NIGHT_DOCTOR) {
                        const aliveCount = room.players.filter(p => p.isAlive && p.role === ROLES.DOCTOR).length;
                        const voteCount = Object.keys(gs.voteList?.doctor || {}).length;
                        
                        if (now >= gs.phaseEndTime || voteCount >= aliveCount) {
                            const votes = gs.voteList || {};
                            const mafiaTargets = Object.values(votes.mafia || {});
                            const doctorTargets = Object.values(votes.doctor || {});
                            const policeTargets = Object.values(votes.police || {});
                            const alivePlayers = room.players.filter(p=>p.isAlive);
                            
                            const mafiaTarget = getNightActionTarget(mafiaTargets, alivePlayers.filter(p=>p.role !== ROLES.MAFIA).map(p=>p.uid));
                            let doctorTarget = getNightActionTarget(doctorTargets, alivePlayers.map(p=>p.uid));
                            
                            let finalDoctorTarget = doctorTarget;
                            if (doctorTarget && doctorTarget === room.lastHealedId) finalDoctorTarget = null;
                            
                            const policeTarget = getNightActionTarget(policeTargets, alivePlayers.map(p=>p.uid)); 
                            let deadId = (mafiaTarget && mafiaTarget !== finalDoctorTarget) ? mafiaTarget : null;
                            
                            const newPlayers = room.players.map(p => p.uid === deadId ? { ...p, isAlive: false } : p);
                            const winResult = checkWin(newPlayers);

                            if(winResult) {
                                await updateDoc(doc(db, 'rooms', roomId), { 
                                    players: newPlayers, 
                                    'gameState.phase': PHASES.GAME_OVER, 
                                    'gameState.logs': arrayUnion({ winner: winResult, dead: getNick(room, deadId) }) 
                                }); 
                                return;
                            }

                            updates = {
                                players: newPlayers, lastHealedId: finalDoctorTarget || null,
                                'gameState.phase': PHASES.DAY_INTRO, 'gameState.phaseEndTime': now + 10000,
                                'gameState.logs': arrayUnion({
                                    mafiaKill: mafiaTarget ? getNick(room, mafiaTarget) : "ì§€ì • ì•ˆí•¨", 
                                    doctorSave: finalDoctorTarget ? getNick(room, finalDoctorTarget) : "ì§€ì • ì•ˆí•¨",
                                    policeInvest: policeTarget ? (room.players.find(p=>p.uid === policeTarget)?.role) : "ì§€ì • ì•ˆí•¨", 
                                    dead: getNick(room, deadId)
                                })
                            };
                        }
                    } 
                    else if (gs.phase === PHASES.DAY_INTRO && now >= gs.phaseEndTime) {
                        updates = { 'gameState.phase': PHASES.DAY_VOTE, 'gameState.phaseEndTime': now + (180 * 1000), 'gameState.voteList.day': {} };
                    } 
                    else if (gs.phase === PHASES.DAY_VOTE) {
                        const aliveCount = room.players.filter(p => p.isAlive).length;
                        const voteCount = Object.keys(gs.voteList?.day || {}).length;
                        if (now >= gs.phaseEndTime || voteCount >= aliveCount) {
                             updates = { 'gameState.phase': PHASES.DAY_VOTE_TALLY, 'gameState.phaseEndTime': now + 3000 }; // 3s Tally
                        }
                    }
                    else if (gs.phase === PHASES.DAY_VOTE_TALLY && now >= gs.phaseEndTime) {
                        // Process Votes
                        const votes = Object.values(gs.voteList?.day || {});
                        const voteCounts = votes.reduce((acc, uid) => { acc[uid] = (acc[uid] || 0) + 1; return acc; }, {});
                        let executeId = null, maxV = -1, tied = false;
                        Object.entries(voteCounts).forEach(([uid, count]) => {
                            if (count > maxV) { maxV = count; executeId = uid; tied = false; } else if (count === maxV) { tied = true; }
                        });
                        if (tied || executeId === 'SKIP') executeId = null;

                        let newPlayers = room.players;
                        if (executeId) newPlayers = room.players.map(p => p.uid === executeId ? { ...p, isAlive: false } : p);
                        
                        const winResult = checkWin(newPlayers);
                        
                        // Even if win, we show Result first.
                        let nextPhase = PHASES.DAY_RESULT;
                        if (winResult) {
                             // We add a special flag or handle it in logs to transition to GAME_OVER *after* DAY_RESULT
                             // For simplicity in this structure, we can check win in DAY_RESULT transition logic.
                             // Let's store the winner in a temp field or check it again next loop?
                             // Better: Store `pendingWinner` in gameState
                             updates = {
                                players: newPlayers,
                                'gameState.phase': nextPhase,
                                'gameState.phaseEndTime': now + 10000, 
                                'gameState.dayCount': increment(1),
                                'gameState.lastExecuted': executeId ? { nick: getNick(room, executeId), role: room.players.find(p=>p.uid===executeId).role } : null,
                                'gameState.pendingWinner': winResult // New field to track pending win
                            };
                        } else {
                            updates = {
                                players: newPlayers,
                                'gameState.phase': nextPhase,
                                'gameState.phaseEndTime': now + 10000, 
                                'gameState.dayCount': increment(1),
                                'gameState.lastExecuted': executeId ? { nick: getNick(room, executeId), role: room.players.find(p=>p.uid===executeId).role } : null
                            };
                        }
                    } 
                    else if (gs.phase === PHASES.DAY_RESULT && now >= gs.phaseEndTime) {
                        if (gs.pendingWinner) {
                             updates = { 
                                 'gameState.phase': PHASES.GAME_OVER, 
                                 'gameState.logs': arrayUnion({ winner: gs.pendingWinner, dead: "Game End" }),
                                 'gameState.pendingWinner': null // clear
                             };
                        } else {
                             updates = { 'gameState.phase': PHASES.NIGHT_INTRO, 'gameState.phaseEndTime': now + 3000 };
                        }
                    }
                    if (Object.keys(updates).length > 0) { await updateDoc(doc(db, 'rooms', roomId), updates); }
                }, 1000);
                return () => clearInterval(interval);
            }, [room, roomId]);
            return null;
        }

        function getNightActionTarget(votes, candidateUids) {
            if (votes.length === 0) {
                if (candidateUids.length === 0) return null;
                return candidateUids[Math.floor(Math.random() * candidateUids.length)];
            }
            const voteCounts = votes.reduce((acc, uid) => { if(candidateUids.includes(uid)) { acc[uid] = (acc[uid] || 0) + 1; } return acc; }, {});
            const tally = Object.entries(voteCounts);
            if(tally.length === 0) {
                if (candidateUids.length === 0) return null;
                return candidateUids[Math.floor(Math.random() * candidateUids.length)];
            }
            let max = -1, winner = null, tied = false;
            tally.forEach(([uid, count]) => { if (count > max) { max = count; winner = uid; tied = false; } else if (count === max) { tied = true; } });
            if (tied) { const tiedCandidates = tally.filter(([, count]) => count === max).map(([uid]) => uid); return tiedCandidates[Math.floor(Math.random() * tiedCandidates.length)]; }
            return winner;
        }
        
        function getNick(room, uid) {
            if (!uid) return "ì—†ìŒ";
            return room.players.find(p => p.uid === uid)?.nickname || "ì•Œìˆ˜ì—†ìŒ";
        }
        function checkWin(players) {
            const alive = players.filter(p => p.isAlive);
            const mafia = alive.filter(p => p.role === ROLES.MAFIA).length;
            const citizens = alive.length - mafia;
            if (mafia === 0) return 'citizen';
            if (mafia >= citizens) return 'mafia';
            return null;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
